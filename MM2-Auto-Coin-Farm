local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "FRXCTURED'S MM2",
   LoadingTitle = "FrxcturedMM2 Suite",
   LoadingSubtitle = "by Frxctured",
   ConfigurationSaving = { Enabled = false },
   KeySystem = false
})

-- STATE
getgenv().Config = {
    Farm = false,
    ESP = true,
    GunESP = true,
    AutoHide = true,
    SubtleESP = true,
    Speed = 50,
    SafetyDist = 18,
    HideDepth = -50,
    MinWait = 0.2 -- Minimum adaptive floor
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local playerRoles, collectedCoins, isHiding, isInRound = {}, {}, false, false
local collectedCount, currentMax, lastHrpPos, bodyVelocity = 0, 50, hrp.Position, nil

-- TABS
local MainTab = Window:CreateTab("Farming", 4483362458)
local VisualsTab = Window:CreateTab("Visuals", 4483345998)

MainTab:CreateToggle({
   Name = "Coin Farm",
   CurrentValue = false,
   Callback = function(Value) getgenv().Config.Farm = Value end,
})

MainTab:CreateSlider({
   Name = "Farm Speed",
   Range = {25, 85},
   Increment = 1,
   Suffix = " studs/s",
   CurrentValue = 50,
   Callback = function(Value) getgenv().Config.Speed = Value end,
})

--- ### 1. NOCLIP ENGINE ### ---
RunService.Stepped:Connect(function()
    if getgenv().Config.Farm and character then
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then part.CanCollide = false end
        end
    end
end)

--- ### 2. THE ADAPTIVE ENGINE ### ---
local function getMurderer()
    for name, data in pairs(playerRoles) do
        if data.Role == "Murderer" and name ~= player.Name then
            local p = Players:FindFirstChild(name)
            if p and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then return p.Character.HumanoidRootPart end
        end
    end
    return nil
end

task.spawn(function()
    while true do
        character = player.Character
        hrp = character and character:FindFirstChild("HumanoidRootPart")
        
        if getgenv().Config.Farm and isInRound and hrp then
            local mHrp = getMurderer()
            local distToMurd = mHrp and (mHrp.Position - hrp.Position).Magnitude or math.huge
            
            -- Auto-Hide Logic
            if getgenv().Config.AutoHide and distToMurd < getgenv().Config.SafetyDist then
                if not isHiding then lastHrpPos = hrp.Position isHiding = true end
                hrp.CFrame = CFrame.new(hrp.Position.X, getgenv().Config.HideDepth, hrp.Position.Z)
                task.wait(0.5) continue
            elseif isHiding then 
                isHiding = false 
                hrp.CFrame = CFrame.new(hrp.Position.X, lastHrpPos.Y + 2, hrp.Position.Z) 
            end

            -- Full Bag Check
            if collectedCount >= currentMax and currentMax > 0 then
                if character:FindFirstChild("Humanoid") then character.Humanoid.Health = 0 end
                isInRound = false task.wait(5) continue
            end

            -- BodyVelocity Init
            if not bodyVelocity or bodyVelocity.Parent ~= hrp then
                if bodyVelocity then bodyVelocity:Destroy() end
                bodyVelocity = Instance.new("BodyVelocity", hrp)
                bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
                if character:FindFirstChild("Humanoid") then character.Humanoid.PlatformStand = true end
            end

            -- Target Selection
            local target, shortest = nil, math.huge
            for _, v in pairs(workspace:GetDescendants()) do
                if v.Name == "Coin_Server" and not collectedCoins[v] then
                    local d = (v.Position - hrp.Position).Magnitude
                    if d < shortest then shortest = d target = v end
                end
            end

            -- ADAPTIVE MOVEMENT LOGIC
            if target then
                local distanceToCoin = (target.Position - hrp.Position).Magnitude
                
                -- ### THE ADAPTIVE WAIT ###
                -- Pause is calculated based on distance / threshold (approx 35 studs per second)
                -- This ensures the server "sees" you moving at a legal rate.
                local adaptiveDelay = math.clamp(distanceToCoin / 35, getgenv().Config.MinWait, 2.5)
                
                bodyVelocity.Velocity = Vector3.zero
                task.wait(adaptiveDelay)

                while getgenv().Config.Farm and target and target.Parent and (target.Position-hrp.Position).Magnitude > 0.5 do
                    if isHiding or not isInRound then break end
                    bodyVelocity.Velocity = (target.Position - hrp.Position).Unit
                    RunService.Heartbeat:Wait()
                end
                
                if bodyVelocity then bodyVelocity.Velocity = Vector3.zero end
                collectedCoins[target] = true
                task.wait(0.1) -- Small tick for server sync
            end
        else
            if bodyVelocity then bodyVelocity:Destroy() bodyVelocity = nil end
        end
        RunService.Heartbeat:Wait()
    end
end)

-- (Include the standard VisualsTab and Remote Listeners from previous version)
